package rs.ac.bg.etf.pp1;

import java_cup.runtime.*;
import org.apache.log4j.*;

// import java.io.*;
import rs.ac.bg.etf.pp1.ast.*;


parser code {:
	
	boolean errorDetected = false;
	
	Logger log = Logger.getLogger(getClass());
   
   
    // slede redefinisani metodi za prijavu gresaka radi izmene teksta poruke
     
    public void report_fatal_error(String message, Object info) throws java.lang.Exception {
      done_parsing();
      report_error(message, info);
    }
  
    public void syntax_error(Symbol cur_token) {
        report_error("\nSintaksna greska", cur_token);
    }
  
    public void unrecovered_syntax_error(Symbol cur_token) throws java.lang.Exception {
        report_fatal_error("Fatalna greska, parsiranje se ne moze nastaviti", cur_token);
    }

    public void report_error(String message, Object info) {
    	errorDetected = true;
    	StringBuilder msg = new StringBuilder(message); 
    	if (info instanceof Symbol)
            msg.append (" na liniji ").append(((Symbol)info).left);
        log.error(msg.toString());
    }
    
    public void report_info(String message, Object info) {
    	StringBuilder msg = new StringBuilder(message); 
    	if (info instanceof Symbol)
            msg.append (" na liniji ").append(((Symbol)info).left);
        log.info(msg.toString());
    }
    
:}

scan with {:
	Symbol s = this.getScanner().next_token();
	if (s != null && s.value != null) 
		log.info(s.toString() + " " + s.value.toString());
	return s;
:}


				// poredjano po redu iz pdfa mikrojava_20_21
								// kljucne reci:
terminal PROG, BREAK, CLASS, ENUM, ELSE, CONST, IF, SWITCH, DO, WHILE, NEW;
terminal PRINT, READ, RETURN, VOID, EXTENDS, CONTINUE, CASE;
								// Vrste tokena:
terminal String IDENT;
terminal Integer NUMBER_CONST;
terminal Char CHAR_CONST;
terminal Boolean  BOOL_CONST;
								// Operatori:
terminal PLUS, MINUS, MUL,DIV, MOD, EQUAL, NEQUAL, GT, GE, LT, LE, AND, OR;
terminal ASSIGN, INC, DEC, SEMI, COMMA, DOT, LPAREN, RPAREN, LSQUARE, RSQUARE;
terminal LBRACE, RBRACE, QMARK, DOTS;
 
								//Dodati neterminali
nonterminal ConstDecl, ClassDecl, DesignatorStatement;
nonterminal ActPars, Condition, CondTerm, CondFact;
nonterminal Assignop, Relop, Mulop;
								// Ovi dole su vec postojali u sablon fajlu
								
nonterminal MethodDeclList, VarDecl;
nonterminal FormalParamList, FormalParamDecl, FormPars, ActualParamList; 
nonterminal StatementList, Statement, Addop;
nonterminal ConstVarClassDeclList, ConstDeclList, ConstDeclOne, VarDeclOne;
nonterminal Extends, ManyVarDecl, CaseList, ReturnExpr, PrintValue;
nonterminal OneMinus, TermsInExpr, IdentOrExpr, ExprManjiProstiji;

// nonterminal rs.etf.pp1.symboltable.concepts.Obj Program, ProgName, Designator, MethodDecl, MethodTypeName; 
// nonterminal rs.etf.pp1.symboltable.concepts.Struct Type, Term, Expr, Factor, VarDeclList; 

nonterminal Program, ProgName, Designator, MethodDecl, MethodTypeName; 
nonterminal Type, Term, Expr, Factor, VarDeclList; 

Program ::= (Program) PROG ProgName:p ConstVarClassDeclList LBRACE MethodDeclList RBRACE 
;

ProgName ::= (ProgName) IDENT:pName 
;
								  
ConstVarClassDeclList ::= (ConstVarClassDeclList_Const) ConstVarClassDeclList ConstDecl
						| (ConstVarClassDeclList_Var) ConstVarClassDeclList VarDecl
						| (ConstVarClassDeclList_Class) ConstVarClassDeclList ClassDecl
						| (ConstVarClassDeclList_No) /* epsilon */ ;
 
ConstDecl ::= (ConstDeclaration) CONST Type ConstDeclList SEMI ;

ConstDeclList ::= 	(ConstDeclList_nadovezivanje) ConstDeclList COMMA ConstDeclOne
				| 	(ConstDeclList_single)	ConstDeclOne
				 ;	
		
							// U primeru u diplomskom radu stoji val 
ConstDeclOne ::= 	(ConstDeclOneElementNumber) IDENT:nName ASSIGN NUMBER_CONST:val
				|	(ConstDeclOneElementChar) IDENT:cName ASSIGN CHAR_CONST:val
				| 	(ConstDeclOneElementBool) IDENT:bName ASSIGN BOOL_CONST:val
				 ;
				

			 
VarDecl ::= (VarDeclaration) Type:varType VarDeclList SEMI  ;

VarDeclList ::= (VarDeclarations) VarDeclList COMMA VarDeclOne
			|	(VarDecListOneElement) VarDeclOne ;


							// Ovo sa greskom pronadjeno na www2.cs.tum.edu..cup..examples	
							// Kako primetih, ovo error nije nigde definisano opet, tako da je 
							// nesto implicitno			
VarDeclOne ::= 	(VarDeclOneNoSquare) IDENT:nameVarOne
			|	(VarDeclOneSquare) IDENT:nameVarOneArray LSQUARE RSQUARE
			| 	(VarDeclERROR) error:eVar     {: parser.report_error("Syntax error, skip rest, linija: "+ tleft ,eVar) ; :}  ;
Type ::= (Type) IDENT:typeName 
 ;

ClassDecl ::= (ClassDeclNoMethod) CLASS IDENT:className Extends LBRACE ManyVarDecl RBRACE 
			| (ClassDeclMethod) CLASS IDENT:className Extends LBRACE ManyVarDecl LBRACE MethodDeclList RBRACE RBRACE  
			 ;

Extends ::= (ExtendClass) EXTENDS Type:extendType ;
									// Ovo je malo dvosmisleno ali valjda nece praviti problem
									// Ako bude problema, ili skloni epsilon ili skloni ovaj One
									// Jer ako imas dva VarDecl, to moze biti i prvo i drugo 
									// i prvo vise puta pa trece
ManyVarDecl ::= (ManyVarDeclaration) ManyVarDecl VarDecl
	//		|	(ManyVarDeclOne) VarDecl
			|	(ManyVarDeclNo) /* epsilon */ ;
		
									 
MethodDeclList ::= (MethodDeclarations) MethodDeclList MethodDecl
					|
					(NoMethodDecl) /* epsilon */
					;

MethodDecl ::= (MethodDeclaration) MethodTypeName LPAREN FormPars RPAREN ManyVarDecl LBRACE StatementList RBRACE ;   

MethodTypeName ::=  (MethodTypeName) Type:retType IDENT:methName
				|	(MethodTypeNameVoid) VOID IDENT:methNameVoid  ;

FormPars ::=  (FormParams) FormalParamList 
			| (NoFormParam) /* epsilon */ ;

FormalParamList ::= (FormalParamDecls) FormalParamList COMMA FormalParamDecl
					|(SingleFormalParamDecl) FormalParamDecl ;
					
FormalParamDecl ::= (FormalParamDecl) Type:paramType IDENT:paramName 
				|	(FormalParamDeclArray) Type:paramType IDENT:paramNameArray LSQUARE RSQUARE ;

StatementList ::= (Statements) StatementList Statement
					|
				  (NoStmt) /* epsilon */ ;

CaseList ::= 	(CaseList) CaseList CASE NUMBER_CONST DOTS StatementList
		| 		(CaseListNoElem) /* epsilon */ ;
		

Statement ::= 	(StatDesign) DesignatorStatement SEMI
			|	(StatIf)	IF LPAREN Condition RPAREN Statement 
			|	(StatIfElse) IF LPAREN Condition RPAREN Statement ELSE Statement 
			|	(StatWhile) DO Statement WHILE LPAREN Condition RPAREN SEMI
			|	(StatBreak) BREAK SEMI 
			|	(StatContinue) CONTINUE SEMI
			| 	(StatRead) READ LPAREN Designator RPAREN SEMI
			|	(StatStat) LBRACE StatementList RBRACE
			|	(StatCase) SWITCH LPAREN Expr RPAREN LBRACE CaseList RBRACE
			|	(StatReturn)	RETURN ReturnExpr SEMI
			|	(StatPrint) PRINT LPAREN Expr PrintValue RPAREN SEMI ;
			
			
ReturnExpr ::=	(ReturnExpr) Expr 
			|	(ReturnNo) /* epsilon */ ;
			
PrintValue ::=	(PrintValue) COMMA NUMBER_CONST
			| 	(PrintNoValue) /* epsilon */ ;
			
			
DesignatorStatement ::= (DStatementAssign) Designator Assignop Expr 
					|	(DStatementParen) Designator LPAREN ActPars RPAREN
					| 	(DStatementInc) Designator INC
					|	(DStatementDec) Designator DEC ;


ActPars ::= (Actuals) ActualParamList 
				| 
			   (NoActuals) /* epsilon */  ;
			   
ActualParamList ::= (ActualParams) ActualParamList COMMA Expr
					|
					(ActualParamEnd) Expr
					 ;
			
Condition ::=(ConditionMulti) 	Condition OR CondTerm
			|	(ConditionEnd)	CondTerm ;
		

CondTerm ::= (CondTermMulti) CondTerm AND CondFact
			 | 
			 (CondTermEnd) CondFact ;

CondFact ::= 	(CondFactOne) 	Expr 
			|	(CondFactRelop)	ExprManjiProstiji Relop ExprManjiProstiji ;
			
				// Uproscavanje jezika malo kako meni odgovara.
				// Negde ExprManjiProstiji, negde sve okej, isproveraaj ovo lepo

Expr ::=  
			ExprManjiProstiji
	 
		| 	(ExprCondFact) CondFact QMARK ExprManjiProstiji DOTS ExprManjiProstiji ;
		
		
ExprManjiProstiji ::= (ExprManjiProstiji) OneMinus Term TermsInExpr ;

OneMinus ::= 	(Minus) 	MINUS
			|	(NoMinus) 	/* epsilon */ ;

TermsInExpr ::= (TermsInExpr) TermsInExpr Addop Term
			|	(NoTermsInExpr) /* epsilon */ ;

Term ::= 	(TermOne) Factor:t
		| 	(TermMore) Term Mulop Factor:t  ;

Factor ::= 	(FactVar) Designator:designName
		|	(FuncCall) Designator:funcName LPAREN ActPars RPAREN
		|	(FactNum) NUMBER_CONST
		|	(FactChar) CHAR_CONST
		|  	(FactBool) BOOL_CONST
		|	(FactNew) NEW Type
		| 	(FactNewArray) NEW Type LSQUARE Expr RSQUARE
		| 	(FactExpr) LPAREN Expr RPAREN ;	

Designator ::= (DesignatorOne) IDENT:destName IdentOrExpr ;

IdentOrExpr ::= (DesignExprOne) DOT IDENT
			|	(DesignIdent) IdentOrExpr DOT IDENT 
			| 	(DesignExprOne) LSQUARE Expr RSQUARE
			| 	(DesignExpr) IdentOrExpr LSQUARE Expr RSQUARE ;

Assignop ::= ASSIGN ;

Relop ::= (RelopEqual) EQUAL
		| (RelopNotEqual) NEQUAL
		| (RelopGreater) GT
		| (RelopGreaterEqual) GE
		| (RelopLower) LT
		| (RelopLowerEqual) LE  ;

Addop ::= (AddopPlus) PLUS 
		| (AddopMinus) MINUS ; 

Mulop ::= (MulopMul) MUL 
		| (MulopDiv) DIV
		| (MulopMod) MOD ;
