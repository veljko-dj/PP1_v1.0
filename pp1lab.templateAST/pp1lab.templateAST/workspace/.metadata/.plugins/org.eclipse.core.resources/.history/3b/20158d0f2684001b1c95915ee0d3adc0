package rs.ac.bg.etf.pp1;

import java_cup.runtime.*;
import org.apache.log4j.*;

// import java.io.*;
import rs.ac.bg.etf.pp1.ast.*;


parser code {:
	
	boolean errorDetected = false;
	
	Logger log = Logger.getLogger(getClass());
   
   
    // slede redefinisani metodi za prijavu gresaka radi izmene teksta poruke
     
    public void report_fatal_error(String message, Object info) throws java.lang.Exception {
      done_parsing();
      report_error(message, info);
    }
  
    public void syntax_error(Symbol cur_token) {
        report_error("\nSintaksna greska", cur_token);
    }
  
    public void unrecovered_syntax_error(Symbol cur_token) throws java.lang.Exception {
        report_fatal_error("Fatalna greska, parsiranje se ne moze nastaviti", cur_token);
    }

    public void report_error(String message, Object info) {
    	errorDetected = true;
    	StringBuilder msg = new StringBuilder(message); 
    	if (info instanceof Symbol)
            msg.append (" na liniji ").append(((Symbol)info).left);
        log.error(msg.toString());
    }
    
    public void report_info(String message, Object info) {
    	StringBuilder msg = new StringBuilder(message); 
    	if (info instanceof Symbol)
            msg.append (" na liniji ").append(((Symbol)info).left);
        log.info(msg.toString());
    }
    
:}

scan with {:
	Symbol s = this.getScanner().next_token();
	if (s != null && s.value != null) 
		log.info(s.toString() + " " + s.value.toString());
	return s;
:}


				// poredjano po redu iz pdfa mikrojava_20_21
								// kljucne reci:
terminal PROG, BREAK, CLASS, ENUM, ELSE, CONST, IF, SWITCH, DO, WHILE, NEW;
terminal PRINT, READ, RETURN, VOID, EXTENDS, CONTINUE, CASE;
								// Vrste tokena:
terminal String IDENT;
terminal Integer NUMBER_CONST;
terminal Char CHAR_CONST;
terminal Boolean  BOOL_CONST;
								// Operatori:
terminal PLUS, MINUS, MUL,DIV, MOD, EQUAL, NEQUAL, GT, GE, LT, LE, AND, OR;
terminal ASSiGN, INC, DEC, SEMI, COMMA, DOT, LPAREN, RPAREN, LSQUARE, RSQUARE;
terminal LBRACE, RBRACE, QMARK, DOTS;
 
								//Dodati neterminali
nonterminal ConstDecl, ClassDecl, DesignatorStatement;
nonterminal ActPars, Condition, CondTerm, CondFact;
nonterminal Assignop, Relop, Mulop;
								// Ovi dole su vec postojali u sablon fajlu
								
nonterminal MethodDeclList, VarDecl;
nonterminal FormalParamList, FormalParamDecl, FormPars, ActualPars, ActualParamList; 
nonterminal StatementList, Statement, Addop;
nonterminal Unmatched, Matched;

nonterminal rs.etf.pp1.symboltable.concepts.Obj Program, ProgName, Designator, MethodDecl, MethodTypeName; 
nonterminal rs.etf.pp1.symboltable.concepts.Struct Type, Term, Expr, Factor, VarDeclList; 

Program ::= (Program) PROG ProgName:p ConstVarClassDeclList LBRACE MethodDeclList RBRACE 
;

ProgName ::= (ProgName) IDENT:pName 
;
								  
ConstVarClassDeclList ::= (ConstVarClassDeclList_Const) ConstVarClassDeclList ConstDecl
						| (ConstVarClassDeclList_Var) ConstVarClassDeclList VarDecl
						| (ConstVarClassDeclList_Class) ConstVarClassDeclList ClassDecl
						| (ConstVarClassDeclList_No) /* epsilon */
						;
 
ConstDecl ::= (ConstDeclaration) CONST Type ConstDeclList SEMI;

ConstDeclList :: = 	(ConstDeclList_nadovezivanje) ConstDeclList COMMA ConstDeclOne
				| 	(ConstDeclList_single)	ConstDeclOne
				;	
		
							// U primeru u diplomskom radu stoji val 
ConstDeclOne ::= 	(ConstDeclOneElementNumber) IDENT:nName ASSIGN NUMBER_CONST:val
				|	(ConstDeclOneElementChar) IDENT:cName ASSIGN CHAR_CONST:val
				| 	(ConstDeclOneElementBool) IDENT:bName ASSIGN BOOL_CONST:val
				;
				

			 
VarDecl ::= (VarDeclaration) Type:varType VarDeclList SEMI ;

VarDeclList ::= (VarDeclarations) VarDeclList COMMA VarDeclOne
			|	(VarDecListOneElement) VarDeclOne;


							// Ovo sa greskom pronadjeno na www2.cs.tum.edu..cup..examples	
							// Kako primetih, ovo error nije nigde definisano opet, tako da je 
							// nesto implicitno			
VarDeclOne ::= 	(VarDeclOneNoSquare) IDENT:nameVarOne
			|	(VarDeclOneSquare) IDENT:nameVarOneArray LSQUARE RSQUARE
			| 	(VarDeclERROR) error:eVar     {: parser.report_error("Syntax error, skip rest, linija: "+ tleft ,eVar); :}

Type ::= (Type) IDENT:typeName 
;

ClassDecl ::= (ClassDeclNoMethod) CLASS IDENT:className Extends LBRACE ManyVarDecl RBRACE 
			| (ClassDeclMethod) CLASS IDENT:className Extends LBRACE ManyVarDecl LBRACE MethodDeclList RBRACE RBRACE  
			;

Extends ::= (ExtendClass) EXTENDS Type:extendType;
									// Ovo je malo dvosmisleno ali valjda nece praviti problem
									// Ako bude problema, ili skloni epsilon ili skloni ovaj One
									// Jer ako imas dva VarDecl, to moze biti i prvo i drugo 
									// i prvo vise puta pa trece
ManyVarDecl ::= (ManyVarDeclaration) ManyVarDecl VarDecl
	//		|	(ManyVarDeclOne) VarDecl
			|	(ManyVarDeclNo) /* epsilon */
								


									 
MethodDeclList ::= (MethodDeclarations) MethodDeclList MethodDecl
					|
					(NoMethodDecl) /* epsilon */
					;

MethodDecl ::= (MethodDeclaration) MethodTypeName LPAREN FormPars RPAREN ManyVarDecl LBRACE StatementList RBRACE     ;   ???STATEMENT???

MethodTypeName ::=  (MethodTypeName) Type:retType IDENT:methName
				|	(MethodTypeNameVoid VOID IDENT:methNameVoid ;

FormPars ::=  (FormParams) FormalParamList 
			| (NoFormParam) /* epsilon */ ;

FormalParamList ::= (FormalParamDecls) FormalParamList COMMA FormalParamDecl
					|
					(SingleFormalParamDecl) FormalParamDecl
					;
					
FormalParamDecl ::= (FormalParamDecl) Type:paramType IDENT:paramName 
				|	(FormalParamDeclArray) Type:paramType IDENT:paramNameArray LSQUARE RSQUARE;

StatementList ::= (Statements) StatementList Statement 
					|
				  (NoStmt) /* epsilon */
				  ;

Statement ::= (MatchedStmt) Matched | (UnmachedStmt) Unmatched ;

Unmatched ::= (UnmatchedIf) IF Expr Statement | (UnmatchedIfElse) IF Expr Matched ELSE Unmatched;
	
				  
Matched ::= (Assignment) Designator:dest EQUAL Expr:e SEMI 
			  |
			  (ErrAssignment) Designator EQUAL error SEMI
			  {: parser.log.debug("Uspesan oporavak od greske pri dodeli vrednosti."); :}
			  |
			  (PrintStmt) PRINT LPAREN Expr RPAREN SEMI 
			  |
			  (ReturnExpr) RETURN Expr:t SEMI
			  |
			  (ReturnNoExpr) RETURN SEMI
			  | 
			  (MatchedIf) IF Expr Matched ELSE Matched
			  |
			  (ProcCall) Designator:func LPAREN ActualPars RPAREN SEMI
			  ;
			  

DesignatorStatement ::= (DStatementAssign) Designator Assignop Expr 
					|	(DStatementParen) Designator LPAREN ActPars RPAREN
					| 	(DStatementInc) Designator INC
					|	(DStatementDec) Designator DEC;


ActPars ::= (Actuals) ActualParamList 
				| 
			   (NoActuals) /* epsilon */ 
			   ;
			   
ActualParamList ::= (ActualParams) ActualParamList COMMA Expr
					|
					(ActualParamEnd) Expr
					;
					 
Condition ::= (Conditions) CondTermList;

CondTermList ::=(CondTermListMulti) 	CondTermList OR CondTerm
			|	(CondTermListEnd)	CondTerm;
					 
CondTerm ::= (CondTerms) CondFactList;


CondFactList ::= (CondFactMulti) CondFactList AND CondFact
			 | 
			 (CondFactEnd) CondFact;

CondFact ::= 	(CondFactOne) 	Expr 
			|	(CondFactRelop)	Expr Relop Expr;

Expr ::= 	(SignleTermInExpr) OneMinus Term
		|	(MultiTermInExpr) OneMinus Term TermsInExpr
	//	| 	Condition QMARK Expr DOTS Expr
		| 	(ExprCondFact) CondFact QMARK Expr DOTS Expr;
		
OneMinus ::= 	(Minus) 	MINUS
			|	(NoMinus) 	/* epsilon */;

TermsInExpr ::= (TermsInExpr) TermsInExpr Addop Term 
			|	(NoTermsInExpr) /* epsilon */;

Term ::= 	(TermOne) Factor:t
		| 	(TermMore) Term Mulop Factor:t
;

Factor ::= 	(FactVar) Designator:desName
		|	(FuncCall) Designator:funcName LPAREN ActualPars RPAREN
		|  	(FactBool) BOOL_CONST
		|	(FactChar) CHAR_CONST
		|	(FactNum) NUMBER_CONST
		|	(FactNew) NEW Type
		| 	(FactNewArray) NEW Type LSQUARE Expr RSQAURE
		| 	(FactExpr) LPAREN Expr RPAREN;		;

Designator ::= (DesignatorOne) IDENT:destName IdentOrExpr;

IdentOrExpr ::= (DesignExprOne) DOT IDENT
			|	(DesignIdent) IdentOrExpr DOT IDENT 
			| 	(DesignExprOne) LSQUARE Expr RSQUARE
			| 	(DesignExpr) IdentOrExpr LSQUARE Expr RSQUARE

Assignop ::= ASSIGN;

Relop ::= (RelopEqual) EQUAL
		| (RelopNotEqual) NEQUAL
		| (RelopGreater) GT
		| (RelopGreaterEqual) GE
		| (RelopLower) LT
		| (RelopLowerEqual) LE ;

Addop ::= (AddopPlus) PLUS 
		| (AddopMinus) MINUS;

Mulop ::= (MulopMul) MUL 
		| (MulopDiv) DIV
		| (MulopMod) MOD;
