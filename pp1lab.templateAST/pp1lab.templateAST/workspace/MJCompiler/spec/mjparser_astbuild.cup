package rs.ac.bg.etf.pp1;

import java_cup.runtime.*;
import org.apache.log4j.*;

// import java.io.*;
import rs.ac.bg.etf.pp1.ast.*;


parser code {:
	
	boolean errorDetected = false;
	
	Logger log = Logger.getLogger(getClass());
   
   
    // slede redefinisani metodi za prijavu gresaka radi izmene teksta poruke
     
    public void report_fatal_error(String message, Object info) throws java.lang.Exception {
      done_parsing();
      report_error(message, info);
    }
  
    public void syntax_error(Symbol cur_token) {
        report_error("\nSintaksna greska", cur_token);
    }
  
    public void unrecovered_syntax_error(Symbol cur_token) throws java.lang.Exception {
        report_fatal_error("Fatalna greska, parsiranje se ne moze nastaviti", cur_token);
    }

    public void report_error(String message, Object info) {
    	errorDetected = true;
    	StringBuilder msg = new StringBuilder(message); 
    	if (info instanceof Symbol)
            msg.append (" na liniji ").append(((Symbol)info).left);
        log.error(msg.toString());
    }
    
    public void report_info(String message, Object info) {
    	StringBuilder msg = new StringBuilder(message); 
    	if (info instanceof Symbol)
            msg.append (" na liniji ").append(((Symbol)info).left);
        log.info(msg.toString());
    }
    
:}

scan with {:
	Symbol s = this.getScanner().next_token();
	if (s != null && s.value != null) 
		log.info(s.toString() + " " + s.value.toString());
	return s;
:}


				// poredjano po redu iz pdfa mikrojava_20_21
								// kljucne reci:
terminal PROG, BREAK, CLASS, ENUM, ELSE, CONST, IF, SWITCH, DO, WHILE, NEW;
terminal PRINT, READ, RETURN, VOID, EXTENDS, CONTINUE, CASE;
								// Vrste tokena:
terminal String IDENT;
terminal Integer NUMBER_CONST;
terminal Character CHAR_CONST;
terminal String  BOOL_CONST;		// Primetimo da ne postoji Boolean i da je Char a ne Character
								// Operatori:
terminal PLUS, MINUS, MUL,DIV, MOD, EQUAL, NEQUAL, GT, GE, LT, LE, AND, OR;
terminal ASSIGN, INC, DEC, SEMI, COMMA, DOT, LPAREN, RPAREN, LSQUARE, RSQUARE;
terminal LBRACE, RBRACE, QMARK, DOTS;
 
								//Dodati neterminali
nonterminal ConstDecl ConstDecl;
nonterminal ClassDecl ClassDecl;
nonterminal DesignatorStatement DesignatorStatement;
nonterminal ActPars ActPars;
nonterminal Condition Condition;
nonterminal CondTerm CondTerm;
nonterminal CondFact CondFact;
nonterminal Assignop Assignop;
nonterminal Relop Relop;
nonterminal Mulop Mulop;
								// Ovi dole su vec postojali u sablon fajlu
								
nonterminal MethodDeclList MethodDeclList;
nonterminal VarDecl VarDecl;
nonterminal FormalParamList FormalParamList;
nonterminal FormalParamDecl FormalParamDecl;
nonterminal FormPars FormPars;
nonterminal ActualParamList ActualParamList; 
nonterminal StatementList StatementList;
nonterminal Statement Statement;
nonterminal Addop Addop;
nonterminal ConstVarClassDeclList ConstVarClassDeclList;
nonterminal ConstDeclList ConstDeclList;
nonterminal ConstDeclOne ConstDeclOne;
nonterminal VarDeclOne VarDeclOne;
nonterminal Extends Extends;
nonterminal ManyVarDecl ManyVarDecl;
nonterminal CaseList CaseList;
nonterminal PrintValue PrintValue;
nonterminal OneMinus OneMinus;
nonterminal TermsInExpr TermsInExpr;
nonterminal IdentOrExpr IdentOrExpr;
nonterminal ExprManjiProstiji ExprManjiProstiji;
nonterminal Unmatched Unmatched;
nonterminal Matched Matched;
nonterminal Epsilon Epsilon;
nonterminal Array Array;
nonterminal RetType RetType;
nonterminal Stagod Stagod;


nonterminal Program Program;
nonterminal ProgName ProgName;
nonterminal Designator Designator;
nonterminal MethodDecl MethodDecl;
nonterminal MethodTypeName MethodTypeName; 
nonterminal Type Type;
nonterminal Term Term;
nonterminal Expr Expr;
nonterminal Factor Factor;
nonterminal VarDeclList VarDeclList; 

Program ::= (Program) PROG ProgName:p ConstVarClassDeclList:C1 LBRACE MethodDeclList:M2 RBRACE {: RESULT=new Program(p, C1, M2); RESULT.setLine(pleft); :} 
;

ProgName ::= (ProgName) IDENT:pName {: RESULT=new ProgName(pName); RESULT.setLine(pNameleft); :} 
;
								  
ConstVarClassDeclList ::= (ConstVarClassDeclList_Const) ConstVarClassDeclList:C1 ConstDecl:C2 {: RESULT=new ConstVarClassDeclList_Const(C1, C2); RESULT.setLine(C1left); :}
						| (ConstVarClassDeclList_Var) ConstVarClassDeclList:C1 VarDecl:V2 {: RESULT=new ConstVarClassDeclList_Var(C1, V2); RESULT.setLine(C1left); :}
						| (ConstVarClassDeclList_Class) ConstVarClassDeclList:C1 ClassDecl:C2 {: RESULT=new ConstVarClassDeclList_Class(C1, C2); RESULT.setLine(C1left); :}
						| (ConstVarClassDeclList_No) Epsilon:E1 {: RESULT=new ConstVarClassDeclList_No(E1); RESULT.setLine(E1left); :} ;
 
ConstDecl ::= (ConstDeclaration) CONST Type:T1 ConstDeclList:C2 SEMI {: RESULT=new ConstDeclaration(T1, C2); RESULT.setLine(T1left); :} ;

ConstDeclList ::= 	(ConstDeclList_nadovezivanje) ConstDeclList:C1 COMMA ConstDeclOne:C2 {: RESULT=new ConstDeclList_nadovezivanje(C1, C2); RESULT.setLine(C1left); :}
				| 	(ConstDeclList_single)	ConstDeclOne:C1 {: RESULT=new ConstDeclList_single(C1); RESULT.setLine(C1left); :}
				 ;	
		
							// U primeru u diplomskom radu stoji val 
ConstDeclOne ::= 	(ConstDeclOneElementNumber) IDENT:nName ASSIGN NUMBER_CONST:val {: RESULT=new ConstDeclOneElementNumber(nName, val); RESULT.setLine(nNameleft); :}
				|	(ConstDeclOneElementChar) IDENT:cName ASSIGN CHAR_CONST:val {: RESULT=new ConstDeclOneElementChar(cName, val); RESULT.setLine(cNameleft); :}
				| 	(ConstDeclOneElementBool) IDENT:bName ASSIGN BOOL_CONST:val {: RESULT=new ConstDeclOneElementBool(bName, val); RESULT.setLine(bNameleft); :}
				 ;
				

			 
VarDecl ::= (VarDeclaration) Type:varType VarDeclList:V1 SEMI {: RESULT=new VarDeclaration(varType, V1); RESULT.setLine(varTypeleft); :}  ;

VarDeclList ::= (VarDeclarations) VarDeclList:V1 COMMA VarDeclOne:V2 {: RESULT=new VarDeclarations(V1, V2); RESULT.setLine(V1left); :}
			|	(VarDecListOneElement) VarDeclOne:V1 {: RESULT=new VarDecListOneElement(V1); RESULT.setLine(V1left); :} ;


							// Ovo sa greskom pronadjeno na www2.cs.tum.edu..cup..examples	
							// Kako primetih, ovo error nije nigde definisano opet, tako da je 
							// nesto implicitno			
VarDeclOne ::= 	(VarDeclOneNoSquare) IDENT:nameVarOne {: RESULT=new VarDeclOneNoSquare(nameVarOne); RESULT.setLine(nameVarOneleft); :}
			|	(VarDeclOneSquare) IDENT:nameVarOneArray LSQUARE RSQUARE {: RESULT=new VarDeclOneSquare(nameVarOneArray); RESULT.setLine(nameVarOneArrayleft); :}
			| 	(VarDeclERROR) error:eVar     {: parser.report_error("Syntax error, skip rest, linija: " ,eVar) ; :} {: RESULT=new VarDeclERROR(); :}  ;
Type ::= (Type) IDENT:typeName {: RESULT=new Type(typeName); RESULT.setLine(typeNameleft); :} 
 ;

ClassDecl ::= (ClassDeclNoMethod) CLASS IDENT:className Extends:E1 LBRACE ManyVarDecl:M2 RBRACE {: RESULT=new ClassDeclNoMethod(className, E1, M2); RESULT.setLine(classNameleft); :} 
			| (ClassDeclMethod) CLASS IDENT:className Extends:E1 LBRACE ManyVarDecl:M2 LBRACE MethodDeclList:M3 RBRACE RBRACE {: RESULT=new ClassDeclMethod(className, E1, M2, M3); RESULT.setLine(classNameleft); :}  
			 ;

Extends ::= (ExtendClass) EXTENDS Type:extendType {: RESULT=new ExtendClass(extendType); RESULT.setLine(extendTypeleft); :}
			| {: RESULT=new ExtendsDerived1(); :} /* epsilon */ ;
									// Ovo je malo dvosmisleno ali valjda nece praviti problem
									// Ako bude problema, ili skloni epsilon ili skloni ovaj One
									// Jer ako imas dva VarDecl, to moze biti i prvo i drugo 
									// i prvo vise puta pa trece
ManyVarDecl ::= (ManyVarDeclaration) ManyVarDecl:M1 VarDecl:V2 {: RESULT=new ManyVarDeclaration(M1, V2); RESULT.setLine(M1left); :}
	//		|	(ManyVarDeclOne) VarDecl
			|	(ManyVarDeclNo) Epsilon:E1 {: RESULT=new ManyVarDeclNo(E1); RESULT.setLine(E1left); :} ;
		
									 
MethodDeclList ::= (MethodDeclarations) MethodDeclList:M1 MethodDecl:M2 {: RESULT=new MethodDeclarations(M1, M2); RESULT.setLine(M1left); :}
					|
					(NoMethodDecl) Epsilon:E1 {: RESULT=new NoMethodDecl(E1); RESULT.setLine(E1left); :}
					;

MethodDecl ::= (MethodDeclaration) MethodTypeName:M1 LPAREN FormPars:F2 RPAREN ManyVarDecl:M3 LBRACE StatementList:S4 RBRACE {: RESULT=new MethodDeclaration(M1, F2, M3, S4); RESULT.setLine(M1left); :} ;   

MethodTypeName ::=  (MethodTypeName) RetType:rett IDENT:methodName {: RESULT=new MethodTypeName(rett, methodName); RESULT.setLine(rettleft); :} ;
			
										
RetType ::= (RetType1) Type:typeRet {: RESULT=new RetType1(typeRet); RESULT.setLine(typeRetleft); :} 
		|	(RetVoid1) VOID:voidRet {: RESULT=new RetVoid1(); :} ;
		

FormPars ::=  (FormParams) FormalParamList:F1 {: RESULT=new FormParams(F1); RESULT.setLine(F1left); :} 
			| (NoFormParam) Epsilon:E1 {: RESULT=new NoFormParam(E1); RESULT.setLine(E1left); :} ;

FormalParamList ::= (FormalParamDecls) FormalParamList:F1 COMMA FormalParamDecl:F2 {: RESULT=new FormalParamDecls(F1, F2); RESULT.setLine(F1left); :}
					|(SingleFormalParamDecl) FormalParamDecl:F1 {: RESULT=new SingleFormalParamDecl(F1); RESULT.setLine(F1left); :} ;
					
FormalParamDecl ::= // (FormalParamDecl) Type:paramType IDENT:paramName |
				 (FormalParamDeclArray) Type:paramType IDENT:paramNameArry  Array:A1 {: RESULT=new FormalParamDeclArray(paramType, paramNameArry, A1); RESULT.setLine(paramTypeleft); :};
				 			// Ovde je bacalo gresku neku u .java fajlu da ne moze da nadje parent
				 			// bla bla bla i kao lek za to sam ubacio ovaj Array
				
Array ::= LSQUARE RSQUARE {: RESULT=new ArrayDerived1(); :} | Epsilon:E1 {: RESULT=new ArrayDerived2(E1); RESULT.setLine(E1left); :};

StatementList ::= (Statements) StatementList:S1 Statement:S2 {: RESULT=new Statements(S1, S2); RESULT.setLine(S1left); :}
					|
				  (NoStmt) Epsilon:E1 {: RESULT=new NoStmt(E1); RESULT.setLine(E1left); :} ;


		

Statement ::= (MatchedStmt) Matched:M1 {: RESULT=new MatchedStmt(M1); RESULT.setLine(M1left); :}
		   |
		   (UnmatchedStmt) Unmatched:U1 {: RESULT=new UnmatchedStmt(U1); RESULT.setLine(U1left); :}
		   ; 

Unmatched ::= (UnmatchedIf) IF LPAREN Condition:C1 RPAREN Statement:S2 {: RESULT=new UnmatchedIf(C1, S2); RESULT.setLine(C1left); :}
		 	|
		 	(UnmatchedIfElse) IF LPAREN Condition:C1 RPAREN Matched:M2 ELSE Unmatched:U3 {: RESULT=new UnmatchedIfElse(C1, M2, U3); RESULT.setLine(C1left); :}
		 	;
Matched ::= 	(StatDesign) DesignatorStatement:D1 SEMI {: RESULT=new StatDesign(D1); RESULT.setLine(D1left); :}
	//		|	(StatIf)	IF LPAREN Condition RPAREN Statement 
	//		|	(StatIfElse) IF LPAREN Condition RPAREN Statement ELSE Statement 
			|	(StatWhile) DO Statement:S1 WHILE LPAREN Condition:C2 RPAREN SEMI {: RESULT=new StatWhile(S1, C2); RESULT.setLine(S1left); :}
			|	(StatBreak) BREAK SEMI {: RESULT=new StatBreak(); :} 
			|	(StatContinue) CONTINUE SEMI {: RESULT=new StatContinue(); :}
			| 	(StatRead) READ LPAREN Designator:D1 RPAREN SEMI {: RESULT=new StatRead(D1); RESULT.setLine(D1left); :}
			|	(StatStat) LBRACE StatementList:S1 RBRACE {: RESULT=new StatStat(S1); RESULT.setLine(S1left); :}
			|	(StatCase) SWITCH LPAREN Expr:E1 RPAREN LBRACE CaseList:C2 RBRACE {: RESULT=new StatCase(E1, C2); RESULT.setLine(E1left); :}
			|	(StatReturn)	RETURN Expr:E1 SEMI {: RESULT=new StatReturn(E1); RESULT.setLine(E1left); :}
									// i ovde je razdvojeno kao i za printvalue
			|	(StatReturn2)	RETURN  SEMI {: RESULT=new StatReturn2(); :}
			|	(StatPrint) PRINT LPAREN Expr:E1 RPAREN SEMI {: RESULT=new StatPrint(E1); RESULT.setLine(E1left); :} 
			|	(StatPrint2) PRINT LPAREN Expr:E1 PrintValue:P2 RPAREN SEMI {: RESULT=new StatPrint2(E1, P2); RESULT.setLine(E1left); :} ;
							
							// Problem ovde postoji, ne radi :(StatPrint) PRINT LPAREN Expr PrintValue RPAREN SEMI ;
							// pa sam razdvojio na dva dela. Ne radi jer baca gresku u .java fajlu, pre je bilo PrintValue ::= ... ili epsilon
		
CaseList ::= 	(CaseListt) CaseList:C1 CASE:c Stagod:S2  DOTS:d StatementList:S3 {: RESULT=new CaseListt(C1, S2, S3); RESULT.setLine(C1left); :}
			| 	(CaseListNoElem) {: RESULT=new CaseListNoElem(); :} /* epsilon */ ;	
			
Stagod ::= NUMBER_CONST:N1 {: RESULT=new StagodDerived1(N1); RESULT.setLine(N1left); :} ;

			
PrintValue ::=	(PrintValue) PrintValue:P1 COMMA NUMBER_CONST:N2 {: RESULT=new PrintValue(P1, N2); RESULT.setLine(P1left); :} ;
			
			
DesignatorStatement ::= (DStatementAssign) Designator:D1 Assignop:A2 Expr:E3 {: RESULT=new DStatementAssign(D1, A2, E3); RESULT.setLine(D1left); :} 
					|	(DStatementParen) Designator:D1 LPAREN ActPars:A2 RPAREN {: RESULT=new DStatementParen(D1, A2); RESULT.setLine(D1left); :}
					| 	(DStatementInc) Designator:D1 INC {: RESULT=new DStatementInc(D1); RESULT.setLine(D1left); :}
					|	(DStatementDec) Designator:D1 DEC {: RESULT=new DStatementDec(D1); RESULT.setLine(D1left); :} ;


ActPars ::= (Actuals) ActualParamList:A1 {: RESULT=new Actuals(A1); RESULT.setLine(A1left); :} 
				| 
			   (NoActuals) Epsilon:E1 {: RESULT=new NoActuals(E1); RESULT.setLine(E1left); :}  ;
			   
ActualParamList ::= (ActualParams) ActualParamList:A1 COMMA Expr:E2 {: RESULT=new ActualParams(A1, E2); RESULT.setLine(A1left); :}
					|
					(ActualParamEnd) Expr:E1 {: RESULT=new ActualParamEnd(E1); RESULT.setLine(E1left); :}
					 ;
			
Condition ::=(ConditionMulti) 	Condition:C1 OR CondTerm:C2 {: RESULT=new ConditionMulti(C1, C2); RESULT.setLine(C1left); :}
			|	(ConditionEnd)	CondTerm:C1 {: RESULT=new ConditionEnd(C1); RESULT.setLine(C1left); :} ;
		

CondTerm ::= (CondTermMulti) CondTerm:C1 AND CondFact:C2 {: RESULT=new CondTermMulti(C1, C2); RESULT.setLine(C1left); :}
			 | 
			 (CondTermEnd) CondFact:C1 {: RESULT=new CondTermEnd(C1); RESULT.setLine(C1left); :} ;

CondFact ::= 	(CondFactOne) 	ExprManjiProstiji:E1 {: RESULT=new CondFactOne(E1); RESULT.setLine(E1left); :} 
			|	(CondFactRelop)	ExprManjiProstiji:E1 Relop:R2 ExprManjiProstiji:E3 {: RESULT=new CondFactRelop(E1, R2, E3); RESULT.setLine(E1left); :} ;
			

				// Setio sam se da je Ziza slao mejl i nova gramatika je ovakva:
				// Ali neka tebi tvoja:
				//
				// Expr = Expr1 "?" Expr1 ":" Expr1 | Expr1.
				// Expr1 =  ["-"] Expr1 { Addop Term }.


Expr ::=  	(Expr0) Condition:C1 QMARK ExprManjiProstiji:E2 DOTS ExprManjiProstiji:E3 {: RESULT=new Expr0(C1, E2, E3); RESULT.setLine(C1left); :}
		| 	(Expr1) ExprManjiProstiji:E1 {: RESULT=new Expr1(E1); RESULT.setLine(E1left); :}  ;
		
		
			//ExprManjiProstiji ::= (ExprManjiProstiji)  TermsInExpr
			//					| (ExprManjiProstijiMinus) MINUS TermsInExpr ;
								//Jedva sam dosao do ove kombinacije koja radi. Greska bila u .java
								// ideja pronadjena na netu, na nekom gitu
					
ExprManjiProstiji ::= 	(ExprTermList) ExprManjiProstiji:E1 Addop:A2 Term:T3 {: RESULT=new ExprTermList(E1, A2, T3); RESULT.setLine(E1left); :} 
					|	(ExprTerm) Term:T1 {: RESULT=new ExprTerm(T1); RESULT.setLine(T1left); :} 
					|	(ExprTermMinus) MINUS Term:T1 {: RESULT=new ExprTermMinus(T1); RESULT.setLine(T1left); :} ;

			/*
			OneMinus ::= 	(Minus) 	MINUS
						|	(NoMinus) 	Epsilon ;
			
			TermsInExpr ::= (TermsInExpr) TermsInExpr Addop Term 
						|	(TermsInExprNo) Term
						;
			*/
Term ::= 	(TermMore) Term:T1 Mulop:M2 Factor:t {: RESULT=new TermMore(T1, M2, t); RESULT.setLine(T1left); :}  
		|	(TermOne) Factor:t {: RESULT=new TermOne(t); RESULT.setLine(tleft); :} ;

Factor ::= 	(FactVar) Designator:designName {: RESULT=new FactVar(designName); RESULT.setLine(designNameleft); :}
		|	(FuncCall) Designator:funcName LPAREN ActPars:A1 RPAREN {: RESULT=new FuncCall(funcName, A1); RESULT.setLine(funcNameleft); :}
		|	(FactNum) NUMBER_CONST:N1 {: RESULT=new FactNum(N1); RESULT.setLine(N1left); :}
		|	(FactChar) CHAR_CONST:C1 {: RESULT=new FactChar(C1); RESULT.setLine(C1left); :}
		|  	(FactBool) BOOL_CONST:B1 {: RESULT=new FactBool(B1); RESULT.setLine(B1left); :}
		|	(FactNew) NEW Type:T1 {: RESULT=new FactNew(T1); RESULT.setLine(T1left); :}
		| 	(FactNewArray) NEW Type:T1 LSQUARE Expr:E2 RSQUARE {: RESULT=new FactNewArray(T1, E2); RESULT.setLine(T1left); :}
		| 	(FactExpr) LPAREN Expr:E1 RPAREN {: RESULT=new FactExpr(E1); RESULT.setLine(E1left); :} ;	

Designator ::= (DesignatorOne) IDENT:destName IdentOrExpr:I1 {: RESULT=new DesignatorOne(destName, I1); RESULT.setLine(destNameleft); :}
			| 	(DesignatorJustOne) IDENT:destNameOne {: RESULT=new DesignatorJustOne(destNameOne); RESULT.setLine(destNameOneleft); :} ;

IdentOrExpr ::= (DesignIdentOne) DOT IDENT:I1 {: RESULT=new DesignIdentOne(I1); RESULT.setLine(I1left); :}
			|	(DesignIdent) IdentOrExpr:I1 DOT IDENT:I2 {: RESULT=new DesignIdent(I1, I2); RESULT.setLine(I1left); :} 
			| 	(DesignExprOne) LSQUARE Expr:E1 RSQUARE {: RESULT=new DesignExprOne(E1); RESULT.setLine(E1left); :}
			| 	(DesignExpr) IdentOrExpr:I1 LSQUARE Expr:E2 RSQUARE {: RESULT=new DesignExpr(I1, E2); RESULT.setLine(I1left); :} ;


Assignop ::= ASSIGN {: RESULT=new AssignopDerived1(); :} ;

Relop ::= (RelopEqual) EQUAL {: RESULT=new RelopEqual(); :}
		| (RelopNotEqual) NEQUAL {: RESULT=new RelopNotEqual(); :}
		| (RelopGreater) GT {: RESULT=new RelopGreater(); :}
		| (RelopGreaterEqual) GE {: RESULT=new RelopGreaterEqual(); :}
		| (RelopLower) LT {: RESULT=new RelopLower(); :}
		| (RelopLowerEqual) LE {: RESULT=new RelopLowerEqual(); :}  ;

Addop ::= (AddopPlus) PLUS {: RESULT=new AddopPlus(); :} 
		| (AddopMinus) MINUS {: RESULT=new AddopMinus(); :} ; 

Mulop ::= (MulopMul) MUL {: RESULT=new MulopMul(); :} 
		| (MulopDiv) DIV {: RESULT=new MulopDiv(); :}
		| (MulopMod) MOD {: RESULT=new MulopMod(); :} ;
		
		Epsilon ::= {: RESULT=new EpsilonDerived1(); :} /* epsilon */;
